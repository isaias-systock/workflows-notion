name: Notion on push with semver bump

on:
  push:
    branches:
      - 'master'

jobs:
  notion:
    runs-on: ubuntu-latest
    steps:
      - name: Calculando a versão correta para montar payload
        id: build
        uses: actions/github-script@v7
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_API_KEY }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
          NOTION_CLIENTS_DATABASE_ID: ${{ secrets.NOTION_CLIENTS_DATABASE_ID }}
          CLIENTS_TITLE_PROP: Name
        with:
          script: |
            const NOTION_VERSION = '2022-06-28';
            const DB_ID = process.env.NOTION_DATABASE_ID;
            const CLIENTS_DB_ID = process.env.NOTION_CLIENTS_DATABASE_ID;
            const CLIENTS_TITLE_PROP = process.env.CLIENTS_TITLE_PROP || 'Name';
            const token = process.env.NOTION_TOKEN;

            const PROP_VERSION  = 'Versão';
            const PROP_CLIENTES = 'Clientes';
            const PROP_TIPO     = 'Tipo';
            const PROP_DATA     = 'Data de Lançamento';
            const PROP_RESP     = 'Responsável';
            const PROP_NOTASINT = 'Notas Internas';
            const PROP_ZENDESK  = 'Zendesk';
            const PROP_NOTASCS  = 'Notas CS';

            const commits = (context.payload.commits || []);
            const hasTipo = (msg) => /(^|\s):tipo\s+\S+/i.test(msg || '');
            const chosen = [...commits].reverse().find(c => hasTipo(c.message));

            if (!chosen) {
              core.notice('Nenhum commit com marcador ":tipo" neste push. Nada será enviado ao Notion.');
              core.setOutput('payload','');
              core.setOutput('nextVersion','');
              return;
            }

            const today  = new Date().toISOString().slice(0,10);

            const normalize = (s) => (s || '').normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().trim();
            const splitNames = (s) => (s || '').split(/[,;|]/).map(x=>x.trim()).filter(Boolean);

            const headers = {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json',
              'Notion-Version': NOTION_VERSION
            };

            const semverRe = /^(\d+)\.(\d+)\.(\d+)$/;
            const parseSemver = (s) => {
              const m = (s||'').trim().match(semverRe);
              return m ? { major:+m[1], minor:+m[2], patch:+m[3] } : null;
            };

            const cmpSemver = (a,b) => a.major-b.major || a.minor-b.minor || a.patch-b.patch;

            let start_cursor, max = null, maxStr = null;
            while (true) {
              const res = await fetch(`https://api.notion.com/v1/databases/${DB_ID}/query`, {
                method: 'POST', headers,
                body: JSON.stringify({ page_size: 100, start_cursor })
              });
              
              if (!res.ok) {
                const t = await res.text();
                core.setFailed(`Erro ao consultar Notion DB: ${res.status} ${t}`); return;
              }
              
              const data = await res.json();
              for (const page of data.results || []) {
                const prop = page.properties?.[PROP_VERSION];
                const title = (prop?.type === 'title' ? prop.title : null) || [];
                const text = (title[0]?.plain_text || '').trim();
                const v = parseSemver(text);
                if (v && (!max || cmpSemver(v,max) > 0)) { max = v; maxStr = text; }
              }
              
              if (!data.has_more) break;
              start_cursor = data.next_cursor;
            }
            
            if (!max) { max = {major:0, minor:0, patch:0}; maxStr = '0.0.0'; }

            const fullMsg = (chosen.message || '').trim();
            const parts = fullMsg.split(/\r?\n\r?\n/);
            const title = (parts[0] || '').trim();
            const body  = parts.slice(1).join('\n\n').trim();

            const rgx = {
              tipo: /:tipo\s+(.+?)(?=\s+:\w+|$)/is,
              cliente: /:cliente\s+(.+?)(?=\s+:\w+|$)/is,
              zendesk: /:zendesk\s+(\S+)(?=\s+:\w+|$)/is,
              notascs: /:notascs?\s+(.+?)(?=\s+:\w+|$)/is,
              responsavel: /:responsaveis?\s+(.+?)(?=\s+:\w+|$)/is
            };

            const tags = {};
            for (const [k,re] of Object.entries(rgx)) {
              const m = body.match(re);
              if (m) tags[k] = m[1].trim();
            }

            const tipoOriginal = tags.tipo || '';
            const tipoNorm = normalize(tipoOriginal);
            const isBug = ['bug','fix','hotfix','correcao','correção'].includes(tipoNorm);
            const isMelhoria = ['melhoria','feature','feat','improvement','enhancement'].includes(tipoNorm);

            let next = {...max};
            if (isBug)      next.patch += 1;
            else if (isMelhoria) next.minor += 1;
            const nextStr = `${next.major}.${next.minor}.${next.patch}`;

            const normalizeUrl = (u) => {
              if (!u) return '';
              let t = u.trim();
              t = t.replace(/^https\/\/:/i, 'https://');
              if (!/^https?:\/\//i.test(t)) t = 'https://' + t.replace(/^https?[:/]+/i,'');
              return t;
            };

            const clienteNames = splitNames(tags.cliente || '');
            const zendeskTxt = normalizeUrl(tags.zendesk || '');
            const notasCSTxt = tags.notascs || '';
            let respNamesFromTag = splitNames(tags.responsavel || '');

            const wantedPeople = 
              respNamesFromTag.length ? respNamesFromTag
                                      : [ chosen.author?.name || context.payload.pusher?.name || '' ].filter(Boolean);

            const listAllUsers = async () => {
              const out = [];
              let cursor;

              while (true) {
                const url = new URL('https://api.notion.com/v1/users');
                if (cursor) url.searchParams.set('start_cursor', cursor);
                
                const r = await fetch(url, { headers });
                if (!r.ok) { const t = await r.text(); core.setFailed(`Erro ao listar usuários: ${r.status} ${t}`); return []; }
                
                const j = await r.json();
                out.push(...(j.results || []));
                
                if (!j.has_more) break;
                cursor = j.next_cursor;
              }
            
              return out;
            };

            const allUsers = await listAllUsers();
            
            const norm = (s) => normalize(s || '');
            const splitWords = (s) => (s || '').trim().split(/\s+/).filter(Boolean);
            const initials = (s) => splitWords(s).map(w => w[0] || '').join('');
            
            const scoreUser = (user, needleRaw) => {
              const needle = norm(needleRaw);
              if (!needle) return 0;
            
              const name = norm(user.name || '');
              const email = norm(user.person?.email || '');
              const nameWords = splitWords(name);
              const needleWords = splitWords(needle);
            
              if (email && (email === needle)) return 100;
              if (name && (name === needle)) return 90;
              if (name && name.startsWith(needle)) return 80;
              if (name && name.includes(needle)) return 70;
              if (nameWords.some(w => w === needle || w.startsWith(needle) || needle.startsWith(w))) return 65;
              if (initials(name) === needle || initials(needle) === initials(name)) return 60;
            
              return 0;
            };
            
            const findUsersFuzzy = (candidates, allUsers) => {
              const chosen = [];
              const seenIds = new Set();
            
              for (const cand of candidates) {
              let best = null, bestScore = 0;
              for (const u of allUsers) {
              const s = scoreUser(u, cand);
              if (s > bestScore) { bestScore = s; best = u; }
            }
              if (best && bestScore >= 60 && !seenIds.has(best.id)) {
              chosen.push(best);
              seenIds.add(best.id);
            } else {
              core.warning(`Responsável não encontrado com bom match para: "${cand}"`);
            }
            }
  
              return chosen;
            };
  
            respNamesFromTag = splitNames(tags.responsavel || '');
            const candidateStrings = respNamesFromTag.length
              ? respNamesFromTag
              : (() => {
                  const fullAuthor = chosen.author?.name || context.payload.pusher?.name || '';
                  const first = (fullAuthor.trim().split(/\s+/)[0] || '');
                return first ? [first] : [];
              })();

            const peopleMatched = findUsersFuzzy(candidateStrings, allUsers);              
            const peopleResolved = peopleMatched.map(u => ({ id: u.id }));

            const findClientPageId = async (name) => {
              if (!name || !CLIENTS_DB_ID) return null;

              const query = async (filter) => {
                const r = await fetch(`https://api.notion.com/v1/databases/${CLIENTS_DB_ID}/query`, {
                  method: 'POST', headers,
                  body: JSON.stringify({ page_size: 5, filter })
                });

                if (!r.ok) { const t = await r.text(); core.warning(`Query clientes falhou (${name}): ${r.status} ${t}`); return []; }
                const j = await r.json();
                return j.results || [];
              };

              let results = await query({ property: CLIENTS_TITLE_PROP, title: { equals: name } });
              if (!results.length) results = await query({ property: CLIENTS_TITLE_PROP, title: { contains: name } });
              return results[0]?.id || null;
            };

            const clientIds = [];
            for (const n of clienteNames) {
              const id = await findClientPageId(n);
              if (id) clientIds.push(id);
              else core.warning(`Cliente não encontrado no DB de Clientes: "${n}"`);
            }

            let bodyLimpo = body;
            for (const re of Object.values(rgx)) bodyLimpo = bodyLimpo.replace(re, '').trim();

            core.info(`Última versão: ${maxStr} | Nova: ${nextStr}`);
            core.info(`Tipo: "${tipoOriginal || 'N/A'}" | Resp (candidatos): [${candidateStrings.join(', ')}] | Resp (IDs): [${peopleResolved.map(p=>p.id).join(', ')}] | Clientes: [${clientIds.join(', ')}]`);
            
            const payload = {
              parent: { database_id: DB_ID },
              properties: {
                [PROP_VERSION]:  { title: [{ text: { content: nextStr } }] },
                [PROP_TIPO]:     { select: { name: (tipoOriginal || 'Bug') } },
                [PROP_DATA]:     { date: { start: today } },
                [PROP_NOTASINT]: { rich_text: title ? [{ text: { content: title } }] : [] },
                [PROP_ZENDESK]:  { rich_text: zendeskTxt ? [{ text: { content: zendeskTxt } }] : [] },
                [PROP_NOTASCS]:  { rich_text: notasCSTxt ? [{ text: { content: notasCSTxt } }] : [] },
                [PROP_RESP]:     { people: peopleResolved },
                [PROP_CLIENTES]: { relation: clientIds.map(id => ({ id })) }
              }
            };

            core.setOutput('nextVersion', nextStr);
            core.setOutput('payload', JSON.stringify(payload));

      - name: Enviando o registro para o Notion
        if: ${{ steps.build.outputs.payload != '' }}
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_API_KEY }}
        run: |
          curl -sS -X POST "https://api.notion.com/v1/pages" \
            -H "Authorization: Bearer $NOTION_TOKEN" \
            -H "Content-Type: application/json" \
            -H "Notion-Version: 2022-06-28" \
            --data '${{ steps.build.outputs.payload }}'