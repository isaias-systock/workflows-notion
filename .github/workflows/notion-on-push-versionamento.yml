name: Notion on push with semver bump

on:
  push:
    branches:
      - 'master'

jobs:
  notion:
    runs-on: ubuntu-latest
    steps:
      - name: Calculando a versão correta para montar payload
        id: build
        uses: actions/github-script@v7
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_API_KEY }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        with:
          script: |
            const NOTION_VERSION = '2022-06-28';
            const DB_ID = process.env.NOTION_DATABASE_ID;
            const token = process.env.NOTION_TOKEN;

            const PROP_VERSION  = 'Versão';
            const PROP_CLIENTES = 'Clientes';
            const PROP_TIPO     = 'Tipo';
            const PROP_DATA     = 'Data de Lançamento';
            const PROP_RESP     = 'Responsável';
            const PROP_NOTASINT = 'Notas Internas';
            const PROP_ZENDESK  = 'Zendesk';
            const PROP_NOTASCS  = 'Notas CS';

            const commits = (context.payload.commits || []);
            const hasTipo = (msg) => /(^|\s):tipo\s+\S+/i.test(msg || '');
            const chosen = [...commits].reverse().find(c => hasTipo(c.message));

            if (!chosen) {
              core.notice('Nenhum commit com marcador ":tipo" neste push. Nada será enviado ao Notion.');
              core.setOutput('payload','');
              core.setOutput('nextVersion','');
              return;
            }

            const author = chosen.author?.name || context.payload.pusher?.name || 'Desconhecido';
            const today  = new Date().toISOString().slice(0,10);

            const semverRe = /^(\d+)\.(\d+)\.(\d+)$/;
            const parseSemver = (s) => {
              const m = (s||'').trim().match(semverRe);
              return m ? { major:+m[1], minor:+m[2], patch:+m[3] } : null;
            };

            const cmpSemver = (a,b) => a.major-b.major || a.minor-b.minor || a.patch-b.patch;

            const headers = {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json',
              'Notion-Version': NOTION_VERSION
            };

            let start_cursor, max = null, maxStr = null;
            while (true) {
              const res = await fetch(`https://api.notion.com/v1/databases/${DB_ID}/query`, {
                method: 'POST', headers,
                body: JSON.stringify({ page_size: 100, start_cursor })
              });
              
              if (!res.ok) {
                const t = await res.text();
                core.setFailed(`Erro ao consultar Notion DB: ${res.status} ${t}`);
                return;
              }
              
              const data = await res.json();
              for (const page of data.results || []) {
                const prop = page.properties?.[PROP_VERSION];
                const title = (prop?.type === 'title' ? prop.title : null) || [];
                const text = (title[0]?.plain_text || '').trim();
                const v = parseSemver(text);
                if (v && (!max || cmpSemver(v,max) > 0)) { max = v; maxStr = text; }
              }
              
              if (!data.has_more) break;
              start_cursor = data.next_cursor;
            }
            
            if (!max) { max = {major:0, minor:0, patch:0}; maxStr = '0.0.0'; }

            const fullMsg = (chosen.message || '').trim();
            const parts = fullMsg.split(/\r?\n\r?\n/);
            const title = (parts[0] || '').trim();
            const body  = parts.slice(1).join('\n\n').trim();

            const rgx = {
              tipo:    /:tipo\s+(.+?)(?=\s+:\w+|$)/is,
              cliente: /:cliente\s+(.+?)(?=\s+:\w+|$)/is,
              zendesk: /:zendesk\s+(\S+)(?=\s+:\w+|$)/is,
              notascs: /:notascs?\s+(.+?)(?=\s+:\w+|$)/is
            };

            const tags = {};
            for (const [k,re] of Object.entries(rgx)) {
              const m = body.match(re);
              if (m) tags[k] = m[1].trim();
            }

            const normalize = (s) => (s || '').normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().trim();
            const tipoOriginal = tags.tipo || '';
            const tipoNorm = normalize(tipoOriginal);
            const isBug = ['bug','fix','hotfix','correcao','correção'].includes(tipoNorm);
            const isMelhoria = ['melhoria','feature','feat','improvement','enhancement'].includes(tipoNorm);

            let next = {...max};
            if (isBug) {
              next.patch += 1;
            } else if (isMelhoria) {
              next.minor += 1;
            } else {
              core.notice('Marcador :tipo não reconhecido; versão mantida.');
            }

            const nextStr = `${next.major}.${next.minor}.${next.patch}`;

            const normalizeUrl = (u) => {
              if (!u) return '';
              let t = u.trim();
              t = t.replace(/^https\/\/:/i, 'https://');
              if (!/^https?:\/\//i.test(t)) t = 'https://' + t.replace(/^https?[:/]+/i,'');
              return t;
            };

            const clienteTxt = tags.cliente || '';
            const zendeskTxt = normalizeUrl(tags.zendesk || '');
            const notasCSTxt = tags.notascs || '';

            let bodyLimpo = body;
            for (const re of Object.values(rgx)) bodyLimpo = bodyLimpo.replace(re, '').trim();
            
            core.info(`Commit escolhido: ${chosen.id.substring(0,7)} | Última versão: ${maxStr} | Nova: ${nextStr}`);

            const payload = {
              parent: { database_id: DB_ID },
              properties: {
                [PROP_VERSION]:  { title: [{ text: { content: nextStr } }] },
                [PROP_CLIENTES]: { rich_text: clienteTxt ? [{ text: { content: clienteTxt } }] : [] },
                [PROP_TIPO]:     { select: { name: (tipoOriginal || 'N/A') } },
                [PROP_DATA]:     { date: { start: today } },
                [PROP_RESP]:     { multi_select: [{ name: author }] },
                [PROP_NOTASINT]: { rich_text: title ? [{ text: { content: title } }] : [] },
                [PROP_ZENDESK]:  { rich_text: zendeskTxt ? [{ text: { content: zendeskTxt } }] : [] },
                [PROP_NOTASCS]:  { rich_text: notasCSTxt ? [{ text: { content: notasCSTxt } }] : [] }
              }
            };

            core.setOutput('nextVersion', nextStr);
            core.setOutput('payload', JSON.stringify(payload));

      - name: Enviado o registro para o Notion
        if: ${{ steps.build.outputs.payload != '' }}
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_API_KEY }}
        run: |
          curl -sS -X POST "https://api.notion.com/v1/pages" \
            -H "Authorization: Bearer $NOTION_TOKEN" \
            -H "Content-Type: application/json" \
            -H "Notion-Version: 2022-06-28" \
            --data '${{ steps.build.outputs.payload }}'